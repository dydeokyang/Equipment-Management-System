---
---
<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>QR 스캐너 (비품번호/비품명/위치/사용자 · KST · 중복방지+CSV)</title>

<!-- 캐시 무효화 (Jekyll time stamp 쿼리) -->
<script>
(function () {
  const APP_VERSION = '{{ site.time | date: "%Y%m%d%H%M%S" }}';
  const url = new URL(location.href);
  if (url.searchParams.get('v') !== APP_VERSION) {
    url.searchParams.set('v', APP_VERSION);
    location.replace(url.toString());
  }
})();
</script>

<style>
  :root{
    --bg:#fff; --fg:#16181b; --muted:#667085; --border:#e6e8eb;
    --shadow:0 4px 14px rgba(0,0,0,.08);
    --chip-id:#eef2ff;     --chip-id-text:#1d4ed8;
    --chip-name:#ecfdf5;   --chip-name-text:#065f46;
    --chip-loc:#fff7ed;    --chip-loc-text:#9a3412;
    --chip-owner:#fef2f2;  --chip-owner-text:#b91c1c;
  }
  body{font-family:system-ui,malgun gothic,apple sd gothic neo,arial;background:var(--bg);color:var(--fg);
       max-width:860px;margin:28px auto;padding:0 16px}
  h1{font-size:22px;margin:14px 0}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin:12px 0}
  button{font-size:16px;padding:9px 14px;border:1px solid var(--border);border-radius:8px;background:#fff;cursor:pointer}
  button:hover{border-color:#c9ced6}
  #video{width:100%;max-width:520px;display:none;border:1px solid var(--border);border-radius:12px;margin:10px 0;box-shadow:var(--shadow)}
  .card{background:#fff;border:1px solid var(--border);border-radius:12px;box-shadow:var(--shadow);padding:14px;margin:14px 0}
  .subtitle{color:var(--muted);font-size:13px;margin-top:-6px;margin-bottom:10px}
  table{border-collapse:separate;border-spacing:0;width:100%}
  th,td{padding:12px 12px;border-bottom:1px solid var(--border);text-align:left;word-break:break-all}
  tbody tr:nth-child(even){background:#fcfdff}
  tbody tr:last-child td, tbody tr:last-child th{border-bottom:0}
  #msg{color:#b00;margin:6px 2px}
  .count{margin-left:auto;color:#333;font-size:14px}
  .mono{font-family:ui-monospace,SFMono-Regular,Consolas,monospace}

  th.key{font-weight:600;border:0;background:transparent;padding:6px 0}
  .chip{display:inline-block;padding:4px 10px;border-radius:999px;font-size:13px}
  .chip.id   {background:var(--chip-id);   color:var(--chip-id-text)}
  .chip.name {background:var(--chip-name); color:var(--chip-name-text)}
  .chip.loc  {background:var(--chip-loc);  color:var(--chip-loc-text)}
  .chip.owner{background:var(--chip-owner);color:var(--chip-owner-text)}

  .list{display:grid;grid-template-columns:1fr;gap:12px}
  @media (min-width:680px){ .list{grid-template-columns:1fr 1fr} }
  .item{border:1px solid var(--border);border-radius:12px;padding:12px;background:#fff;box-shadow:var(--shadow)}
  .item .head{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  .item .time{font-size:13px;color:#334155;background:#f1f5f9;border-radius:6px;padding:4px 8px}
  .badges{display:flex;flex-wrap:wrap;gap:6px}
  .badge{font-size:12px;border-radius:999px;padding:3px 8px}
  .badge.id   {background:var(--chip-id);   color:var(--chip-id-text)}
  .badge.name {background:var(--chip-name); color:var(--chip-name-text)}
  .badge.loc  {background:var(--chip-loc);  color:var(--chip-loc-text)}
  .badge.owner{background:var(--chip-owner);color:var(--chip-owner-text)}
</style>
</head>
<body>
<h1>QR 스캐너</h1>

<div class="row">
  <button id="startBtn">카메라 시작</button>
  <button id="imageBtn" title="사진을 촬영/선택해서 인식합니다.">사진으로 스캔</button>
  <button id="exportBtn">CSV 내보내기</button>
  <button id="clearBtn"  title="저장된 모든 레코드를 삭제합니다.">초기화</button>
  <span class="count" id="count">저장 0건</span>
</div>

<video id="video" playsinline muted></video>
<input id="fileInput" type="file" accept="image/*;capture=camera" style="display:none" />
<p id="msg"></p>

<div class="card">
  <h2>비품정보</h2>
  <div class="subtitle">스캔 즉시 아래 표에 표시됩니다.</div>
  <table id="tbl"><tbody></tbody></table>
</div>

<div class="card">
  <h2>최근 저장 목록 <span class="mono" style="font-size:12px;color:#475569">(KST 기준)</span></h2>
  <div class="subtitle">같은 항목을 다시 스캔해도 중복 저장하지 않고, 시간만 갱신합니다.</div>
  <div id="list" class="list"></div>
</div>

<!-- 권장: 로컬 고정 버전 -->
<script src="/lib/jsqr.min.js"></script>
<!-- CDN을 쓰려면 위 줄을 지우고 아래 주석을 해제 -->
<!-- <script src="https://unpkg.com/jsqr/dist/jsQR.js"></script> -->

<script>
(() => {
  const video  = document.getElementById('video');
  const msg    = document.getElementById('msg');
  const tbody  = document.querySelector('#tbl tbody');
  const listEl = document.getElementById('list');
  const countEl= document.getElementById('count');
  const fileEl = document.getElementById('fileInput');

  let stream = null, running = false;

  // --- 환경 감지: iOS 여부 (iPhone/iPad WebKit)
  const isIOS = (() => {
    const ua = navigator.userAgent || '';
    const iOSDevice = /iP(hone|ad|od)/.test(ua);
    const webkit = /WebKit/.test(ua);
    const isCriOS = /CriOS/.test(ua); // iOS의 Chrome
    return (iOSDevice && webkit) || isCriOS;
  })();

  // --- 저장: localStorage
  let records = loadRecords(); renderList();
  function loadRecords(){ try{ return JSON.parse(localStorage.getItem('qr_records')||'[]'); } catch(e){ return []; } }
  function saveRecords(){ localStorage.setItem('qr_records', JSON.stringify(records)); }
  function setMsg(t){ msg.textContent = t || ''; }

  // --- 시간(KST)
  function fmtKST(d){
    const p = new Intl.DateTimeFormat('ko-KR',{ timeZone:'Asia/Seoul', year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false }).formatToParts(d);
    const g = t => p.find(x=>x.type===t)?.value || '';
    return `${g('year')}-${g('month')}-${g('day')} ${g('hour')}:${g('minute')}:${g('second')}`;
  }
  function nowKST(){ return fmtKST(new Date()); }

  // --- 중복 키: id 우선, 없으면 raw
  function dedupeKey(o){ const id=(o.id??'').trim(); return id ? 'ID:'+id.toLowerCase() : 'RAW:'+String(o.raw??''); }

  // --- QR 파서(JSON | key=value;… | id:name:loc:owner)
  function parseQR(text){
    let obj = {};
    try { const j = JSON.parse(text); if (j && typeof j==='object') obj = j; }
    catch {
      if (text.includes('=')) {
        text.split(';').forEach(pair=>{
          const pos = pair.indexOf('='); if (pos<0) return;
          const k = pair.slice(0,pos).trim(); const v = pair.slice(pos+1).trim();
          if (k) obj[k] = v;
        });
      } else if (text.includes(':')) {
        const parts = text.split(':');
        if (parts.length >= 4) {
          obj.id    = parts[0].trim();
          obj.name  = parts[1].trim();
          obj.loc   = parts[2].trim();
          obj.owner = parts[3].trim();
        }
      }
    }
    return { id:obj.id??'', name:obj.name??'', loc:obj.loc??'', owner:obj.owner??'', raw:text };
  }

  const FIELD_ORDER = [
    {key:'id',    label:'비품번호', class:'id'},
    {key:'name',  label:'비품명',   class:'name'},
    {key:'loc',   label:'위치',     class:'loc'},
    {key:'owner', label:'사용자',   class:'owner'},
  ];

  function renderTable(o){
    tbody.innerHTML=''; 
    FIELD_ORDER.forEach(({key,label,class:cls})=>{
      const tr=document.createElement('tr');
      const th=document.createElement('th'); th.className='key'; th.innerHTML=`<span class="chip ${cls}">${label}</span>`;
      const td=document.createElement('td'); td.textContent=o[key]??'';
      tr.append(th,td); tbody.appendChild(tr);
    });
  }

  function upsertRecord(o){
    const key = dedupeKey(o);
    const kst = nowKST();
    const idx = records.findIndex(r => r._key===key);
    if (idx>=0){
      const updated={...records[idx], id:o.id,name:o.name,loc:o.loc,owner:o.owner,raw:o.raw, scanned_at_kst:kst};
      records.splice(idx,1); records.push(updated);
      setMsg('이미 저장된 항목입니다. 시간만 갱신했어요.');
    } else {
      records.push({_key:key, id:o.id,name:o.name,loc:o.loc,owner:o.owner, raw:o.raw, scanned_at_kst:kst});
      setMsg('');
    }
    saveRecords(); renderList();
  }

  function renderList(){
    listEl.innerHTML=''; countEl.textContent=`저장 ${records.length}건`;
    records.slice().reverse().forEach(r=>{
      const card=document.createElement('div'); card.className='item';
      card.innerHTML = `
        <div class="head"><div class="time mono">${r.scanned_at_kst}</div></div>
        <div class="badges">
          <span class="badge id">비품번호: ${esc(r.id)}</span>
          <span class="badge name">비품명: ${esc(r.name)}</span>
          <span class="badge loc">위치: ${esc(r.loc)}</span>
          <span class="badge owner">사용자: ${esc(r.owner)}</span>
        </div>`;
      listEl.appendChild(card);
    });
  }

  function esc(s){ return String(s??'').replace(/[&<>"]/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;' }[m])); }

  function stop(){
    running=false;
    if(stream){
      stream.getTracks().forEach(t=>t.stop());
      stream=null;
    }
    video.srcObject=null;
    video.style.display='none';
  }

  // --- 카메라 시작: iOS는 무조건 jsQR 폴백 사용
  async function start(){
    if(location.protocol!=='https:' && location.hostname!=='localhost'){ setMsg('실시간 스캔은 HTTPS 또는 localhost에서만 가능합니다.'); return; }
    if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){ setMsg('이 브라우저는 카메라 API를 지원하지 않습니다.'); return; }

    try{
      stop(); // 이전 세션 정리
      video.setAttribute('playsinline','');
      video.setAttribute('muted','');
      video.muted = true;

      const constraints = {
        video:{ facingMode:{ideal:'environment'}, width:{ideal:1280}, height:{ideal:720} },
        audio:false
      };
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject=stream; await video.play();
      video.style.display='block'; running=true; setMsg('QR을 화면에 담아주세요…');

      if (isIOS) { jsqrFallback(); return; }

      // 안드로이드/데스크톱: 네이티브 → 타임아웃 시 폴백
      if('BarcodeDetector' in window){
        const detector = new BarcodeDetector({formats:['qr_code']});
        const useGrab = 'ImageCapture' in window;
        const track   = stream.getVideoTracks()[0];
        const grabber = useGrab ? new ImageCapture(track) : null;
        const started = performance.now();

        const loop = async ()=>{
          if(!running) return;
          try{
            if (performance.now() - started > 1500) { jsqrFallback(); return; }
            let val=null;
            if(useGrab){
              const frame = await grabber.grabFrame();
              const found = await detector.detect(frame);
              val = found && found[0]?.rawValue;
            } else {
              const found = await detector.detect(video);
              val = found && found[0]?.rawValue;
            }
            if(val){
              stop(); const parsed=parseQR(val); renderTable(parsed); upsertRecord(parsed); return;
            }
          }catch{ jsqrFallback(); return; }
          requestAnimationFrame(loop);
        };
        loop();
      } else {
        jsqrFallback();
      }
    }catch(e){
      const map={NotAllowedError:'카메라 권한이 거부되었습니다. 브라우저/사이트 설정에서 허용해주세요.',
                 NotFoundError:'카메라 장치를 찾을 수 없습니다.',
                 NotReadableError:'다른 앱이 카메라 사용 중입니다.',
                 OverconstrainedError:'카메라 조건을 만족하지 못했습니다.',
                 SecurityError:'보안 정책으로 차단되었습니다.'};
      setMsg(map[e.name]||`카메라 오류: ${e.name||e}`);
    }
  }

  // --- iOS 친화 jsQR 폴백 (다운스케일 + 스로틀 + rVFC 우선)
  function jsqrFallback(){
    const c=document.createElement('canvas');
    const x=c.getContext('2d',{ willReadFrequently:true });

    const targetW = 480;  // 360~640 권장
    const minGapMs = 120; // ~8fps
    let last = 0;
    let cancel = false;

    const decodeOnce = ()=>{
      if(!running || cancel) return;
      if(video.readyState !== video.HAVE_ENOUGH_DATA) return;

      const vw = video.videoWidth  || 640;
      const vh = video.videoHeight || 480;
      const ratio = vh / vw;
      c.width  = targetW;
      c.height = Math.round(targetW * ratio);

      x.drawImage(video,0,0,c.width,c.height);
      const img=x.getImageData(0,0,c.width,c.height);
      const qr = jsQR(img.data,img.width,img.height,{ inversionAttempts:'attemptBoth' });
      if(qr && qr.data){
        stop(); const parsed=parseQR(qr.data); renderTable(parsed); upsertRecord(parsed);
      }
    };

    const rVFC = video.requestVideoFrameCallback?.bind(video);
    if (rVFC) {
      const onFrame = (now/*highRes*/)=>{
        if(!running || cancel) return;
        if (now - last >= minGapMs) { last = now; decodeOnce(); }
        rVFC(onFrame);
      };
      rVFC(onFrame);
    } else {
      (function loop(){
        if(!running || cancel) return;
        const now = performance.now();
        if(now - last >= minGapMs){ last = now; decodeOnce(); }
        requestAnimationFrame(loop);
      })();
    }

    const track = stream?.getVideoTracks?.()[0];
    track && track.addEventListener?.('ended', ()=>{ cancel=true; });
  }

  // --- 사진 파일 스캔 (EXIF 회전 보정 + 다운스케일)
  async function scanImageFile(file){
    if(!file){ setMsg('파일이 선택되지 않았습니다.'); return; }
    try{
      setMsg('사진 분석 중…');
      const orientation = await getExifOrientation(file).catch(()=>1);
      const img = await decodeImageFromFile(file);
      const { canvas } = drawOriented(img, 1200, orientation);
      const x = canvas.getContext('2d',{ willReadFrequently:true });
      const d = x.getImageData(0, 0, canvas.width, canvas.height);
      const res = jsQR(d.data, d.width, d.height, { inversionAttempts:'attemptBoth' });

      if(res?.data){
        const parsed = parseQR(res.data); renderTable(parsed); upsertRecord(parsed); setMsg('');
      } else {
        setMsg('QR을 인식하지 못했습니다. (조명/초점/거리 조절 후 다시 시도)');
      }
    }catch(err){
      setMsg('사진 스캔 실패: ' + (err.message || err));
    }
  }

  // --- EXIF Orientation 읽기 (간단 JPEG APP1 파서)
  async function getExifOrientation(file){
    const slice = file.slice(0, 128 * 1024);
    const buf = await slice.arrayBuffer().catch(()=>null);
    if(!buf) return 1;
    const view = new DataView(buf);
    if (view.getUint16(0, false) !== 0xFFD8) return 1; // not JPEG
    let offset = 2, length = view.byteLength;
    while (offset < length) {
      const marker = view.getUint16(offset, false); offset += 2;
      if (marker === 0xFFE1) { // APP1
        const exifLength = view.getUint16(offset, false); offset += 2;
        if (view.getUint32(offset, false) !== 0x45786966) return 1; // "Exif"
        offset += 6;
        const little = view.getUint16(offset, false) === 0x4949;
        offset += 2;
        if (view.getUint16(offset, little) !== 0x002A) return 1;
        offset += 2;
        let dirStart = view.getUint32(offset, little);
        if (!dirStart) return 1;
        dirStart += offset + 4 - 8;
        const entries = view.getUint16(dirStart, little);
        for (let i=0;i<entries;i++){
          const entryOffset = dirStart + 2 + i*12;
          const tag = view.getUint16(entryOffset, little);
          if (tag === 0x0112) return view.getUint16(entryOffset + 8, little) || 1; // Orientation
        }
        return 1;
      } else if ((marker & 0xFF00) !== 0xFF00) break;
      else offset += view.getUint16(offset, false);
    }
    return 1;
  }

  // --- 이미지 디코딩 (iOS 안정화: DataURL 사용)
  function decodeImageFromFile(file){
    return new Promise((resolve, reject)=>{
      const img = new Image();
      img.onload = async ()=>{
        try{ if(img.decode) await img.decode(); }catch(_){}
        resolve(img);
      };
      img.onerror = ()=> reject(new Error('이미지 로드 실패'));
      const r = new FileReader();
      r.onload  = ()=> { img.src = r.result; };
      r.onerror = ()=> reject(new Error('파일 읽기 실패'));
      r.readAsDataURL(file);
    });
  }

  // --- 회전/반전 적용 + 다운스케일 렌더링
  function drawOriented(img, maxW, orientation){
    const iw = img.naturalWidth || img.width;
    const ih = img.naturalHeight || img.height;
    const scale = Math.min(1, maxW / Math.max(iw, ih));
    let w = Math.round(iw * scale), h = Math.round(ih * scale);
    const rotate90 = (o)=> (o===5 || o===6 || o===7 || o===8);
    if (rotate90(orientation)) [w, h] = [h, w];

    const canvas = document.createElement('canvas');
    canvas.width = w; canvas.height = h;
    const x = canvas.getContext('2d', { willReadFrequently: true });

    x.save();
    switch (orientation) {
      case 2: x.translate(w, 0); x.scale(-1, 1); break;
      case 3: x.translate(w, h); x.rotate(Math.PI); break;
      case 4: x.translate(0, h); x.scale(1, -1); break;
      case 5: x.rotate(0.5*Math.PI); x.scale(1, -1); break;
      case 6: x.rotate(0.5*Math.PI); x.translate(0, -h); break;
      case 7: x.rotate(0.5*Math.PI); x.translate(w, -h); x.scale(-1, 1); break;
      case 8: x.rotate(-0.5*Math.PI); x.translate(-w, 0); break;
      default: break;
    }
    if (rotate90(orientation)) x.drawImage(img, 0, 0, h, w);
    else                       x.drawImage(img, 0, 0, w, h);
    x.restore();

    return { canvas, width: canvas.width, height: canvas.height };
  }

  // --- CSV 내보내기 (UTF-8 BOM)
  function exportCSV(){
    if(records.length===0){ setMsg('내보낼 데이터가 없습니다.'); return; }
    const header=['스캔시각(KST)','비품번호','비품명','위치','사용자'];
    const rows = records.map(r=>[ r.scanned_at_kst, r.id, r.name, r.loc, r.owner ]);
    const escCSV=v=>`"${String(v??'').replace(/"/g,'""')}"`;
    const lines=[header.map(escCSV).join(','), ...rows.map(row=>row.map(escCSV).join(','))].join('\r\n');
    const blob=new Blob(["\ufeff"+lines],{type:'text/csv;charset=utf-8;'}); const a=document.createElement('a');
    a.href=URL.createObjectURL(blob); a.download='qr_scans_'+new Date().toISOString().slice(0,10)+'.csv'; a.click();
  }

  function clearAll(){ if(!confirm('저장된 모든 레코드를 삭제할까요?')) return; records=[]; saveRecords(); renderList(); }

  // --- 페이지 숨김 시 정지 (배터리/발열 절감)
  document.addEventListener('visibilitychange', ()=>{ if(document.hidden){ stop(); } });

  // --- 버튼 이벤트
  document.getElementById('startBtn').onclick = ()=> start();
  document.getElementById('exportBtn').onclick= exportCSV;
  document.getElementById('clearBtn').onclick = clearAll;
  document.getElementById('imageBtn').onclick = ()=> fileEl.click();
  fileEl.addEventListener('change', e => scanImageFile(e.target.files?.[0]));
})();
</script>
</body>
</html>

<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>QR 스캐너 (중복방지 + CSV + 자동버전)</title>

<!-- 캐시 약화 메타 -->
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
<meta http-equiv="Pragma" content="no-cache"/>
<meta http-equiv="Expires" content="0"/>

<!-- 자동 버전 쿼리(캐시 버스터): 배포 때 숫자만 +1 -->
<script>
(function () {
  const APP_VERSION = '8'; // ← 다음 배포 시 '9', '10' ... 로만 올리면 됩니다
  const url = new URL(location.href);
  if (url.searchParams.get('v') !== APP_VERSION) {
    url.searchParams.set('v', APP_VERSION);
    location.replace(url.toString()); // 한 번만 새로고침
  }
})();
</script>

<style>
  body{font-family:system-ui,malgun gothic,apple sd gothic neo,arial;max-width:760px;margin:24px auto;padding:0 16px}
  h1{font-size:20px;margin:12px 0}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin:10px 0}
  button{font-size:16px}
  #video{width:100%;max-width:460px;display:none;border:1px solid #eee;border-radius:6px;margin:8px 0}
  table{border-collapse:collapse;width:100%;margin-top:12px}
  th,td{border:1px solid #ddd;padding:8px;text-align:left;word-break:break-all}
  th{width:28%;background:#fafafa}
  #msg{color:#b00;margin:8px 0}
  .count{color:#333;font-size:14px;margin-left:auto}
  ul{padding-left:18px}
</style>
</head>
<body>
<h1>QR 스캐너</h1>

<div class="row">
  <button id="startBtn">카메라 시작</button>
  <button id="exportBtn">CSV 내보내기</button>
  <button id="clearBtn" title="저장된 모든 레코드를 삭제합니다.">초기화</button>
  <span class="count" id="count">저장 0건</span>
</div>

<video id="video" playsinline muted></video>
<p id="msg"></p>

<h2>비품정보</h2>
<table id="tbl"><tbody></tbody></table>

<h2>최근 저장 목록</h2>
<ul id="list"></ul>

<!-- jsQR 폴백용 -->
<script src="https://unpkg.com/jsqr/dist/jsQR.js"></script>
<script>
(() => {
  const video  = document.getElementById('video');
  const msg    = document.getElementById('msg');
  const tbody  = document.querySelector('#tbl tbody');
  const listEl = document.getElementById('list');
  const countEl= document.getElementById('count');

  let stream = null, running = false;

  // 저장 데이터 로드/저장
  let records = loadRecords();
  renderList();

  function loadRecords(){
    try{ return JSON.parse(localStorage.getItem('qr_records')||'[]'); }
    catch(e){ return []; }
  }
  function saveRecords(){ localStorage.setItem('qr_records', JSON.stringify(records)); }
  function setMsg(t){ msg.textContent = t || ''; }

  // 중복 판별용 키: id가 있으면 id, 없으면 raw
  function dedupeKey(o){
    const id = (o.id ?? '').trim();
    if (id) return 'ID:' + id.toLowerCase();
    return 'RAW:' + String(o.raw ?? '');
  }

  // QR 텍스트 파싱 → {id,name,loc,owner, raw}
  function parseQR(text){
    let obj = {};
    // 1) JSON 시도
    try {
      const j = JSON.parse(text);
      if (j && typeof j === 'object') obj = j;
    } catch(e){
      // 2) key=value;key2=value2
      if (text.includes('=')) {
        text.split(';').forEach(p=>{
          const [k, ...rest] = p.split('=');
          if(!k) return;
          const v = rest.join('=');
          obj[k.trim()] = (v ?? '').trim();
        });
      } else if (text.includes(':')) {
        // 3) 콜론 4분절(id:name:loc:owner) 임시 대응
        const parts = text.split(':');
        if (parts.length >= 4) {
          obj.id    = parts[0].trim();
          obj.name  = parts[1].trim();
          obj.loc   = parts[2].trim();
          obj.owner = parts[3].trim();
        }
      }
    }
    return {
      id   : obj.id    ?? '',
      name : obj.name  ?? '',
      loc  : obj.loc   ?? '',
      owner: obj.owner ?? '',
      raw  : text
    };
  }

  function renderTable(o){
    tbody.innerHTML = '';
    const rows = [
      ['id', o.id],
      ['name', o.name],
      ['loc', o.loc],
      ['owner', o.owner]
    ];
    rows.forEach(([k,v])=>{
      const tr=document.createElement('tr');
      const th=document.createElement('th'); th.textContent=k;
      const td=document.createElement('td'); td.textContent=v;
      tr.append(th,td); tbody.appendChild(tr);
    });
  }

  // 중복 방지 업서트: 같은 dedupeKey면 추가하지 않고 시간 갱신 + 최신으로 이동
  function upsertRecord(o){
    const key = dedupeKey(o);
    const now = new Date().toISOString();
    const idx = records.findIndex(r => (r._key === key));
    if (idx >= 0) {
      const updated = {
        ...records[idx],
        id:o.id, name:o.name, loc:o.loc, owner:o.owner, raw:o.raw,
        scanned_at: now
      };
      records.splice(idx, 1);
      records.push(updated);
      setMsg('이미 저장된 항목입니다. 시간만 갱신했어요.');
    } else {
      records.push({
        _key:key, id:o.id, name:o.name, loc:o.loc, owner:o.owner,
        raw:o.raw, scanned_at: now
      });
      setMsg('');
    }
    saveRecords();
    renderList();
  }

  function renderList(){
    listEl.innerHTML = '';
    countEl.textContent = `저장 ${records.length}건`;
    records.slice().reverse().forEach(r=>{
      const li=document.createElement('li');
      li.textContent = `${r.scanned_at} | id:${r.id} | name:${r.name} | loc:${r.loc} | owner:${r.owner}`;
      listEl.appendChild(li);
    });
  }

  function stop(){
    running=false;
    if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
    video.style.display='none';
  }

  async function start(){
    if(location.protocol !== 'https:' && location.hostname !== 'localhost'){
      setMsg('실시간 스캔은 HTTPS 또는 localhost에서만 가능합니다.');
      return;
    }
    if(!navigator.mediaDevices?.getUserMedia){
      setMsg('이 브라우저는 카메라 API를 지원하지 않습니다.');
      return;
    }
    try{
      stream = await navigator.mediaDevices.getUserMedia({
        video:{ facingMode:{ideal:'environment'}, width:{ideal:1280}, height:{ideal:720} }
      });
      video.srcObject=stream; await video.play();
      video.style.display='block'; running=true; setMsg('QR을 화면에 담아주세요…');

      if('BarcodeDetector' in window){
        const detector = new BarcodeDetector({formats:['qr_code']});
        const useGrab = 'ImageCapture' in window;
        const track   = stream.getVideoTracks()[0];
        const grabber = useGrab ? new ImageCapture(track) : null;

        const loop = async ()=>{
          if(!running) return;
          try{
            let val=null;
            if(useGrab){
              const frame = await grabber.grabFrame();
              const found = await detector.detect(frame);
              val = found && found[0]?.rawValue;
            }else{
              const found = await detector.detect(video);
              val = found && found[0]?.rawValue;
            }
            if(val){
              stop();
              const parsed = parseQR(val);
              renderTable(parsed);
              upsertRecord(parsed);
              return;
            }
          }catch(e){
            jsqrFallback(); return;
          }
          requestAnimationFrame(loop);
        };
        loop();
      } else {
        jsqrFallback();
      }
    }catch(e){
      const map={NotAllowedError:'카메라 권한이 거부되었습니다. 브라우저/사이트 설정에서 허용해주세요.',
                 NotFoundError:'카메라 장치를 찾을 수 없습니다.',
                 NotReadableError:'다른 앱이 카메라 사용 중입니다.',
                 OverconstrainedError:'카메라 조건을 만족하지 못했습니다.',
                 SecurityError:'보안 정책으로 차단되었습니다.'};
      setMsg(map[e.name]||`카메라 오류: ${e.name||e}`);
    }
  }

  function jsqrFallback(){
    const c=document.createElement('canvas'), x=c.getContext('2d');
    let last=0;
    (function loop(){
      if(!running) return;
      const now=performance.now();
      if(now-last<120){ requestAnimationFrame(loop); return; }
      last=now;
      if(video.readyState===video.HAVE_ENOUGH_DATA){
        c.width=video.videoWidth||640; c.height=video.videoHeight||480;
        x.drawImage(video,0,0,c.width,c.height);
        const d=x.getImageData(0,0,c.width,c.height);
        const qr=jsQR(d.data,d.width,d.height,{inversionAttempts:'dontInvert'});
        if(qr && qr.data){
          stop();
          const parsed = parseQR(qr.data);
          renderTable(parsed);
          upsertRecord(parsed);
          return;
        }
      }
      requestAnimationFrame(loop);
    })();
  }

  // CSV 내보내기 (UTF-8 BOM으로 엑셀 한글 깨짐 방지)
  function exportCSV(){
    if(records.length===0){ setMsg('내보낼 데이터가 없습니다.'); return; }
    const header = ['scanned_at','id','name','loc','owner'];
    const rows = records.map(r=>[
      r.scanned_at, r.id, r.name, r.loc, r.owner
    ]);
    const esc = v => `"${String(v??'').replace(/"/g,'""')}"`;
    const lines = [header.map(esc).join(','), ...rows.map(row=>row.map(esc).join(','))].join('\r\n');
    const blob = new Blob(["\ufeff"+lines], {type:'text/csv;charset=utf-8;'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'qr_scans_' + new Date().toISOString().slice(0,10) + '.csv';
    a.click();
  }

  // 초기화(저장 데이터만 삭제)
  function clearAll(){
    if(!confirm('저장된 모든 레코드를 삭제할까요?')) return;
    records = []; saveRecords(); renderList();
  }

  // 이벤트
  document.getElementById('startBtn').onclick  = ()=>{ stop(); start(); };
  document.getElementById('exportBtn').onclick = exportCSV;
  document.getElementById('clearBtn').onclick  = clearAll;
})();
</script>
</body>
</html>
